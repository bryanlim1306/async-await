How to use promises

Promises are the foundation of asynchronous programming in modern JavaScript. A promise is an object 
returned by an asynchronous function, which represents the current state of the operation. At the 
time the promise is returned to the caller, the operation often isn't finished, but the promise 
object provides methods to handle the eventual success or failure of the operation.

1. Promise-based API 
    With a promise-based APi, the asynchronous function starts the operation and returns a Promise object.
    You can tell attach handlers to the promise object and the handlers will be executed when the operation 
    has succeeded or failed. 

2. Using the fetch() API
    The fetch() API is the modern, promise-based replacement for XMLHttpRequest.
    We first make an HTTP request to the server. In a HTTP request, we send a request
    message to a remote server and it sends us back a response. 

const fetchPromise = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');

console.log(fetchPromise);

fetchPromise.then((response) => {
  console.log(`Received response: ${response.status}`);
});

console.log("Started request…");

    1. In the above code, we call the fetch() API and assign the return value to the fetchPromise variable 
    2. Logging the fetchPromise variable, this should output something like: Promise {<state: "pending},
       telling us we have a Promise object and its state is "pending". The "pending" state means that the fetch
       operation is still going on. 
    3. Passing a handler function into the Promise's then() method, when and if the fetch operation succeeds, 
       the promise will call our handler, passing in a Response object, which contains the server's response. 
    4. Logging a message that we have started a request. 

This is the completed output: 
Promise { <state>: "pending" }
Started request…
Received response: 200

Note that Started request... is logged before we receive the response. Unlike a synchronous function, fetch() returns
while the request is still going on, enabling our program to stay responsive. The response shows the 200 (OK) status code, 
meaning that our request succeeded. 

Chaining Promises================================================================================================================

Once you get a Response object the fetch() API, you need to call another function to get the response data. 
In this case, we want the response data as JSON, so we would call the json() method of the Response object. 
json() is also asynchronous, so this is a case where we have to call two successive asynchronous functions. 

Example:
const fetchPromise = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');

fetchPromise.then((response) => {
  const jsonPromise = response.json();
  jsonPromise.then((data) => {
    console.log(data[0].name);
  });
});
We add a then() handler to the promise returned by fetch(). But this time, our handler calls response.json() and then passes 
a new then() handler into the promise returned by response.json()

This should log "baked beans" (the name of the first product listed in "products.json")

What differentiates using then() from callback hell, is that then() itself returns a promise, which will be completed with the result
of the function passed to it. Thus, we should rewrite the above code as this.

Example:
const fetchPromise = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');

fetchPromise
  .then((response) => response.json())
  .then((data) => {
    console.log(data[0].name);
  });

Instead of the second then() inside of the handler for the first then(), we can return the promise returned by json()
and then call the second then() on that return value. This is called promise chaining and means we can avoid ever-increasing
levels of indentation when we need to make asynchronous function calls. 

Lastly, we need to check that the server accepted and was able to handle the request, before we try to read it. Check the status code in
the response and throw an error if it wasn't "OK".

Promise terminology================================================================================================================================
A promise can be in one of three states:
1. Pending: Promise has been created, async function has not succeeded or failed yet.
This is the state the promise is in when it's returned from a call to fetch(_) and the request is still being made.

2. fulfilled: the async function has succeeded. When a promise is fulfilled, its then() handler is called.

3. rejected: the async function has failed. When a promise is rejected, its catch() handler is called.

Combining multiple promises==========================================================================================================================
The promise chain is what you need when your operation consists of several async functions, and you need one to complete before starting the next one. 
There are other ways you might need to combine async function calls and the Promise API provides some helpers for them.

Sometimes, you need all the promises to be fulfilled, but they don't depend on each other. In a case like that, it's much more efficient to start them 
together and be notified when they have all fulfilled. The Promise.all() method is what you need here.

The promise returned by Promise.all() is: 
- fulfilled when and if all of the promises in the array are fulfilled. In this case, the then() handler is called with an array of all the responses,
  in the same order that the promises were passed into all()
- rejected when and if any of the promises are rejected. The catch() handler is called with the error thrown by the promise that rejected.

Example: 
const fetchPromise1 = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');
const fetchPromise2 = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found');
const fetchPromise3 = fetch('https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json');

Promise.all([fetchPromise1, fetchPromise2, fetchPromise3])
  .then((responses) => {
    for (const response of responses) {
      console.log(`${response.url}: ${response.status}`);
    }
  })
  .catch((error) => {
    console.error(`Failed to fetch: ${error}`)
  });

Here, we are making three fetch() requests to three different URLs. If they all succeed, we will log the response status of each one. 
If any of them fail, then we're logging the failure. 

With these URLs, all the requests should be fulfilled, although for the second, the server will return 404 (Not Found) instead of 200 (OK)
because the requested file does not exist. 

The output is:
https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json: 200
https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found: 404
https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json: 200

If we try the same code with badly formed URL: 
const fetchPromise1 = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');
const fetchPromise2 = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found');
const fetchPromise3 = fetch('bad-scheme://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json');

Promise.all([fetchPromise1, fetchPromise2, fetchPromise3])
  .then((responses) => {
    for (const response of responses) {
      console.log(`${response.url}: ${response.status}`);
    }
  })
  .catch((error) => {
    console.error(`Failed to fetch: ${error}`)
  });

Then, we can expect the catch() handler to run and see something like:
Failed to fetch: TypeError: Failed to fetch

If you need any one set of promises to be fulfilled and don't care which one, you want Promise.any()
As soon as any of the array of the promises is fulfilled, or rejected if all of them are rejected. 

Example:
const fetchPromise1 = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');
const fetchPromise2 = fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found');
const fetchPromise3 = fetch('https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json');

Promise.any([fetchPromise1, fetchPromise2, fetchPromise3])
  .then((response) => {
    console.log(`${response.url}: ${response.status}`);
  })
  .catch((error) => {
    console.error(`Failed to fetch: ${error}`)
  });

In this case, we can't predict which fetch will complete first. 

async and await====================================================================================================================

The async keyword gives you a simpler way to work with async promise-based code. 
Adding async to the start of a function makes it an async function:

Example:
async function myFunction() {
  // This is an async function
}

Inside an async function, you can use the await keyword before a call to a function that returns a promise. This makes the code wait
at that point until the promise is settled, at which point the fulfilled value of the promise is treated as a return value, or the rejected
value is thrown. 

This enables you to write code that uses async functions but looks like synchronous code.

Example: 
async function fetchProducts() {
  try {
    // after this line, our function will wait for the `fetch()` call to be settled
    // the `fetch()` call will either return a Response or throw an error
    const response = await fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }
    // after this line, our function will wait for the `response.json()` call to be settled
    // the `response.json()` call will either return the parsed JSON object or throw an error
    const data = await response.json();
    console.log(data[0].name);
  }
  catch (error) {
    console.error(`Could not get products: ${error}`);
  }
}

fetchProducts();

Here, we are calling await fetch() and instead of getting a promise, our caller gets back a fully complete Response object, just as
if fetch() were a synchronous function. 

We can even use a try...catch block for error handling, exactly as we would if the code was synchronous.

Note though that async functions always return a Promise
You'd need to do something like:

async function fetchProducts() {
  try {
    const response = await fetch('https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json');
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }
    const data = await response.json();
    return data;
  }
  catch (error) {
    console.error(`Could not get products: ${error}`);
  }
}

const promise = fetchProducts();
promise.then((data) => console.log(data[0].name));

Note that you can only use await inside an async function, unless your code is in a JavaScript module.
Like a promise chain, await forces asynchronous operations to be completed in series. This is necessary
if the result of the next operation depends on the result of the last one, but if that's not the case then
Promise.all() will be more performant. 
